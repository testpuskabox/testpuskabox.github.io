"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParseTree = void 0;
var Tokenizer_1 = require("./Tokenizer");
var Token_1 = require("./Token");
var ParseTree = /** @class */ (function () {
    function ParseTree(options) {
        this.subTrees = [];
        this.type = options.type;
        this.content = options.content;
        if (options.attributes)
            this.attributes = options.attributes;
        if (options.subTrees)
            this.subTrees = options.subTrees;
    }
    Object.defineProperty(ParseTree.prototype, "isValid", {
        get: function () {
            if (!this.subTrees.length)
                return true;
            return this.subTrees.every(function (tree) { return tree.isValid; });
        },
        enumerable: false,
        configurable: true
    });
    ParseTree.prototype.toString = function () {
        return this.type + " - " + this.content;
    };
    ParseTree.buildTree = function (str, tags) {
        var tokenizer = new Tokenizer_1.Tokenizer(tags);
        var tokens = tokenizer.tokenizeString(str);
        var tree = new ParseTree({
            type: ParseTree.Type.root,
            content: str
        });
        return this.buildTreeFromTokens(tree, tokens.reverse());
    };
    // eslint-disable-next-line complexity
    ParseTree.buildTreeFromTokens = function (rootTree, tokens, currentTag) {
        if (currentTag === void 0) { currentTag = ''; }
        if (!rootTree)
            return null;
        if (!tokens.length)
            return rootTree;
        var currentToken = tokens.pop();
        if (!currentToken)
            return null;
        if (currentToken.type === Token_1.Token.Type.text) {
            var newTree = new ParseTree({
                type: ParseTree.Type.text,
                content: currentToken.content
            });
            rootTree.subTrees.push(newTree);
        }
        if (currentToken.type === Token_1.Token.Type.startTag) {
            var tagName = currentToken.content;
            var newTree = new ParseTree({
                type: ParseTree.Type.tag,
                content: tagName,
                attributes: currentToken.attributes
            });
            var tokenTree = ParseTree.buildTreeFromTokens(newTree, tokens, tagName);
            if (!tokenTree)
                return null;
            rootTree.subTrees.push(tokenTree);
        }
        if (currentToken.type === Token_1.Token.Type.endTag) {
            var tagName = currentToken.content;
            if (tagName === currentTag) {
                return rootTree;
            }
            return null;
        }
        if (!tokens.length && currentTag !== '')
            return null;
        return this.buildTreeFromTokens(rootTree, tokens, currentTag);
    };
    return ParseTree;
}());
exports.ParseTree = ParseTree;
(function (ParseTree) {
    var Type;
    (function (Type) {
        Type[Type["root"] = 0] = "root";
        Type[Type["text"] = 1] = "text";
        Type[Type["tag"] = 2] = "tag";
    })(Type = ParseTree.Type || (ParseTree.Type = {}));
})(ParseTree = exports.ParseTree || (exports.ParseTree = {}));
exports.ParseTree = ParseTree;
