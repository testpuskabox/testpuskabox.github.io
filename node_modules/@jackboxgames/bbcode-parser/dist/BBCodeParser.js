"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BBCodeParser = void 0;
var ParseTree_1 = require("./ParseTree");
var Tag_1 = require("./Tag");
var BBCodeParser = /** @class */ (function () {
    function BBCodeParser(tags, options) {
        this.options = options;
        this.escapeHTML = false;
        this.tags = tags;
        if (options) {
            this.escapeHTML = options.escapeHTML;
        }
    }
    Object.defineProperty(BBCodeParser, "defaultTags", {
        get: function () {
            return {
                b: Tag_1.Tag.create('b'),
                i: Tag_1.Tag.create('i')
            };
        },
        enumerable: false,
        configurable: true
    });
    BBCodeParser.prototype.parse = function (content, stripTags, insertLineBreak, escapingHtml) {
        if (stripTags === void 0) { stripTags = false; }
        if (insertLineBreak === void 0) { insertLineBreak = true; }
        if (escapingHtml === void 0) { escapingHtml = true; }
        var parseTree = ParseTree_1.ParseTree.buildTree(content, this.tags);
        // If the tree is invalid, return the input as text
        if (!parseTree || !parseTree.isValid) {
            return content;
        }
        // Convert it to HTML
        return this.treeToHtml(parseTree.subTrees, insertLineBreak, escapingHtml, stripTags);
    };
    BBCodeParser.prototype.addTag = function (name, tag) {
        this.tags[name] = tag;
    };
    BBCodeParser.prototype.treeToHtml = function (subTrees, insertLineBreak, escapingHtml, stripTags) {
        var _this = this;
        if (stripTags === void 0) { stripTags = false; }
        var htmlString = '';
        var suppressLineBreak = false;
        subTrees.forEach(function (tree) {
            var _a;
            if (tree.type === ParseTree_1.ParseTree.Type.text) {
                var textContent = tree.content;
                if (escapingHtml) {
                    textContent = _this.escapeHTML ? BBCodeParser.escapeHTML(textContent) : textContent;
                }
                if (insertLineBreak && !suppressLineBreak) {
                    textContent = textContent.replace(/(\r\n|\n|\r)/gm, '<br>');
                    suppressLineBreak = false;
                }
                htmlString += textContent;
            }
            else {
                var tag = _this.tags[tree.content];
                var content = _this.treeToHtml(tree.subTrees, tag.insertLineBreaks, escapingHtml, stripTags);
                if (!stripTags) {
                    htmlString += tag.markupGenerator(tag, content, (_a = tree.attributes) !== null && _a !== void 0 ? _a : {});
                }
                else {
                    htmlString += content;
                }
                suppressLineBreak = tag.suppressLineBreaks;
            }
        });
        return htmlString;
    };
    BBCodeParser.escapeHTML = function (content) {
        return content.replace(/[&<>]/g, function (tag) { return BBCodeParser.tagsToReplace[tag] || tag; });
    };
    BBCodeParser.tagsToReplace = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;'
    };
    return BBCodeParser;
}());
exports.BBCodeParser = BBCodeParser;
