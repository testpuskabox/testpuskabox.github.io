"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tokenizer = void 0;
var Token_1 = require("./Token");
var Tokenizer = /** @class */ (function () {
    function Tokenizer(tags) {
        this.tags = tags;
    }
    Tokenizer.prototype.tokenizeString = function (str) {
        var _this = this;
        var tokens = this.getTokens(str);
        var newTokens = [];
        var noNesting = false;
        var noNestingTag = '';
        var noNestedTagContent = '';
        tokens.forEach(function (token) {
            var tag = _this.tags[token.content];
            var addTag = true;
            if (!tag && !noNesting) {
                token.convertToTextToken();
            }
            else if (noNesting) {
                if (token.type === Token_1.Token.Type.endTag && token.content === noNestingTag) {
                    noNesting = false;
                    newTokens.push(Tokenizer.createTextToken(noNestedTagContent));
                }
                else {
                    token.convertToTextToken();
                    noNestedTagContent += token.content;
                    addTag = false;
                }
            }
            else if (tag.noNesting && token.type === Token_1.Token.Type.startTag) {
                noNesting = true;
                noNestingTag = token.content;
                noNestedTagContent = '';
            }
            if (addTag) {
                newTokens.push(token);
            }
        });
        return newTokens;
    };
    Tokenizer.prototype.getTokens = function (str) {
        // eslint-disable-next-line max-len
        var pattern = "\\[(/\\w*)\\]|\\[(\\w*)+(=([\"])" + Tokenizer.valueChars + "*\\4)?( (" + Tokenizer.nameChars + "+)?=([\"])(" + Tokenizer.valueChars + "+)\\7)*\\]";
        var tagPattern = new RegExp(pattern, 'g');
        var tokens = [];
        var match = tagPattern.exec(str);
        var lastIndex = 0;
        while (match) {
            var delta_1 = match.index - lastIndex;
            if (delta_1 > 0) {
                tokens.push(Tokenizer.createTextToken(str.substr(lastIndex, delta_1)));
            }
            tokens.push(Tokenizer.createTagToken(match));
            lastIndex = tagPattern.lastIndex;
            match = tagPattern.exec(str);
        }
        var delta = str.length - lastIndex;
        if (delta > 0) {
            tokens.push(Tokenizer.createTextToken(str.substr(lastIndex, delta)));
        }
        return tokens;
    };
    Tokenizer.createTextToken = function (content) {
        return new Token_1.Token(Token_1.Token.Type.text, content);
    };
    Tokenizer.createTagToken = function (match) {
        if (!match[1]) {
            var tagName = match[2];
            var attributes = {};
            var attrPattern = new RegExp("(" + Tokenizer.nameChars + "+)?=([\"])(" + Tokenizer.valueChars + "+)\\2", 'g');
            var attrStr = match[0].substr(1 + tagName.length, match[0].length - 2 - tagName.length);
            var attrMatch = attrPattern.exec(attrStr);
            while (attrMatch) {
                if (!attrMatch[1]) {
                    attributes[tagName] = attrMatch[3];
                }
                else {
                    attributes[attrMatch[1]] = attrMatch[3];
                }
                attrMatch = attrPattern.exec(attrStr);
            }
            return new Token_1.Token(Token_1.Token.Type.startTag, tagName, attributes, match[0]);
        }
        return new Token_1.Token(Token_1.Token.Type.endTag, match[1].substr(1, match[1].length - 1));
    };
    Tokenizer.nameChars = '[a-zA-Z0-9\\.\\-_:;/]';
    Tokenizer.valueChars = '[a-zA-Z0-9\\.\\-_:;#/\\s]';
    return Tokenizer;
}());
exports.Tokenizer = Tokenizer;
