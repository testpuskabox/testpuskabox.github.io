// this stuff should be good everywhere
const WebSocket = require('isomorphic-ws');
const qs = require('qs');

// this stuff might be node-specific
const EventEmitter = require('events');

// this is our stuff
const { CallError } = require('./errors');
const { ClientWelcome } = require('./client');
const { CountGroup } = require('./count_group');
const { DoodleEntity } = require('./doodle');
const { GCounter } = require('./g_counter');
const { Notification } = require('./notification');
const { NumberEntity } = require('./number');
const { ObjectEntity } = require('./object');
const { PNCounter } = require('./pn_counter');
const { Reply } = require('./reply');
const { Request } = require('./request');
const { StackEntity } = require('./stack');
const { TextEntity } = require('./text');
const { TextMapEntity } = require('./text_map');
const { TextRing } = require('./text_ring');
const { parseResponseMessage } = require('./parse');

// Reconnect options
const START_BACKOFF = 1000 + Math.floor(Math.random() * 500); // 1-1.5s initial
const MAX_BACKOFF = 13000; // 13s

/**
 * WSClient is the ecast websocket client. Unlike blobcast, an ecast websocket
 * client cannot be connected without being connected to a room. All connected
 * ecast websockets are connected to exactly one room, which is active. When
 * the room shuts down, the websocket connection is closed. This means it's
 * impossible to have an active websocket connection either before the room has
 * started or after it has ended.
 */
class WSClient extends EventEmitter {
    constructor(options) {
        super();
        this.debug = options.debug || false;

        if (!options.host) {
            throw new Error('unable to create ecast WSClient: no host provided');
        }
        this.host = options.host;

        if (!options.code) {
            throw new Error('unable to create ecast WSClient: no room code provided');
        }
        this.code = options.code;

        if (options.scheme) {
            this.scheme = options.scheme;
        } else {
            this.scheme = 'wss';
        }

        // Only secret and id are required for reconnection, all authorizations were done
        // during the initial connection
        if (options.secret && options.id) {
            this.id = options.id;
            this.secret = options.secret;
        } else {
            switch (options.role) {
                case 'player':
                    if (!options.name) throw new Error('unable to create ecast WSClient: no name provided');
                    break;
                case 'host':
                    if (!options.token) throw new Error('unable to create ecast WSClient: tried to connect with host role but without host token');
                    this.token = options.token;
                    break;
                case 'moderator':
                    if (!options.password) throw new Error('unable to create ecast WSClient: tried to connect with moderator role but without password');
                    break;
                default:
            }

            if (options.password) {
                this.password = options.password;
            }
            if (options.twitchToken) {
                this.twitchToken = options.twitchToken;
            }
        }

        this.name = options.name;
        this.role = options.role;
        this.deviceId = options.deviceId;
        this.userId = options.userId;

        this.conn = null;

        this.seq = 0;
        this.pending = {};
        this.entities = {};

        if (options.role == 'host') {
            this.replaySince = options.replaySince || 0;
            this.syncEntities = options.syncEntities || false;
        }
    }

    // connect connects to the WSClient's target room. connect returns a
    // promise that can be awaited. The preferred method of connecting to a
    // room is to connect and to take action on the connection after that
    // promise has resolved. This allows the server to send any initial
    // configuration to the client before the client takes further action.
    // Right now, that initial configuration is limited to the client's ID.
    connect() {
        const queryParams = {
            id: this.id,
            role: this.role,
            name: this.name,
            format: 'json',
            'user-id': this.userId,
            password: this.password,
        };

        if (this.deviceId) {
            queryParams['device-id'] = this.deviceId;
        }

        if (this.twitchToken) {
            queryParams['twitch-token'] = this.twitchToken;
        }

        if (this.secret) { // reconnecting options
            queryParams.secret = this.secret;
        }

        if (this.role === 'host') {
            queryParams['host-token'] = this.token;

            if (this.replaySince > 0) {
                queryParams['replay-since'] = this.replaySince;
            }

            if (this.syncEntities) {
                queryParams['sync-entities'] = this.syncEntities;
            }
        }

        const query = qs.stringify(queryParams);

        const url = (this.role === 'audience' || this.id > 1e7)
            ? `${this.scheme}://${this.host}/api/v2/audience/${this.code}/play?${query}`
            : `${this.scheme}://${this.host}/api/v2/rooms/${this.code}/play?${query}`;

        return new Promise((resolve, reject) => {
            let resolved = false;
            let welcomed = false;
            let success = (v) => { resolve(v); resolved = true; };
            let failure = (v) => { reject(v); resolved = true; };

            this.conn = new WebSocket(url, 'ecast-v0');

            this.conn.onmessage = (e) => {
                this.debugLog(`recv <- ${JSON.stringify(JSON.parse(e.data), null, 2)}`);
                const res = parseResponseMessage(e);

                if (res instanceof Reply) {
                    this.onReply(res);
                } else if (res instanceof Notification) {
                    if (res.result instanceof ClientWelcome) {
                        welcomed = true;
                        this.id = res.result.id;
                        this.deviceId = res.result.deviceId;
                        this.entities = res.result.entities;
                        this.secret = res.result.secret;

                        // Players might've had their name changed by the server.
                        // Reassigning `this.name` preserves that change in the client.
                        if (res.result.name) {
                            this.name = res.result.name;
                        }

                        success(res.result);
                    } else {
                        if (!resolved) {
                            failure(res.result);
                            return;
                        }
                    }
                    this.onNotification(res);
                } else {
                    // TODO: find a way to handle errors here. I don't think
                    // there should be any, but this path should not be dead.
                    console.error(`failed to parse response messsage: ${res}`);
                }
            };

            this.conn.onerror = (e) => {
                if (resolved) {
                    this.emit('socketError', e);
                } else {
                    failure(e);
                }
            };

            this.conn.onclose = (e) => {
                this.debugLog('onclose', e.code);
                if (welcomed && e.code === 1006) { // Abnormal closure
                    this.reconnect();
                } else {
                    this.emit('socketClose', e);
                }
            };

            this.conn.onopen = (e) => {
                this.emit('socketOpen', e);
                // this event is actually kinda useless since we want to wait
                // until we receive a welcome message before continuing.
            };
        });
    }


    sleep(milliseconds) {
        return new Promise((resolve) => { return setTimeout(resolve, milliseconds); });
    }

    debugLog(...args) {
        if (!this.debug) {
            return;
        }
        console.log(`%c[WSClient:${this.name}]`, 'background-color:blue;color:white;', ...args);
    }

    async reconnect() {
        this.disconnect();
        this.debugLog('Attempting to reconnect');
        let attempt = 1;
        let backoff = START_BACKOFF;
        while (true) {
            try {
                this.emit('connection', { status: 'connecting', attempt });
                await this.connect();
                this.debugLog('reconnected');
                this.emit('connection', { status: 'connected' });
                return;
            } catch (e) {
                this.debugLog('reconnect error', e);
                if (e.code === 1005 || e.code === 1000) { // Server disconnected
                    this.debugLog('unable to reconnect!', e);
                    this.emit('socketClose', e);
                    return;
                }
                if (backoff >= MAX_BACKOFF) {
                    this.debugLog('reconnect failed!', e);
                    this.emit('socketClose', e);
                    return;
                }
                attempt += 1;
                this.debugLog('waiting', backoff);
                this.emit('connection', { status: 'waiting', attempt });
                await this.sleep(backoff);
                backoff = Math.min(MAX_BACKOFF, backoff * 2);
            }
        }
    }

    disconnect() {
        if (!this.conn) return;
        this.conn.close();
        this.conn.onmessage = null;
        this.conn.onerror = null;
        this.conn.onopen = null;
        this.conn.onclose = null;
        this.conn = null;
    }

    onReply(reply) {
        const re = reply.re;
        const pending = this.pending[re];
        if (!pending) {
            const n = new Notification(reply);
            n.re = re;
            this.emit('notification', n);
            return;
        }
        delete this.pending[re];
        if (reply.result instanceof CallError) {
            pending.reject(reply.result);
        } else {
            pending.resolve(reply.result);
        }
    }

    onNotification(notification) {
        if (typeof notification.result.whenReceived === 'function') {
            notification.result.whenReceived(this);
        }
        this.emit('notification', notification);
        this.emit(notification.opcode, notification.result);
    }

    // send is used internally to send an ecast message to an ecast room. Send
    // will return a promise that may be awaited to retrieve the server
    // response. Every request in  ecast receives a response of some sort, so
    // that a client may safely block on sending a request and waiting for a
    // response. Note that responses do not necessarily come back in-order,
    // but ecast-js already handles this so that's not really a concern for
    // ecast-js consumers.
    send(opcode, params = {}) {
        if (!this.conn) {
            throw new Error(`No connection available`);
        }
        if (this.conn.readyState !== WebSocket.OPEN) {
            throw new Error(`Socket not ready to send, readyState is ${this.conn.readyState}`);
        }
        const seq = ++this.seq;
        const request = new Request({
            seq,
            opcode,
            params,
        });
        const p = new Promise((resolve, reject) => {
            this.pending[seq] = {
                resolve,
                reject,
                request,
            };
        });
        const data = JSON.stringify(request);
        this.debugLog(`send -> ${data}`);
        this.conn.send(data);
        return p;
    }

    // room/lock: locks the room so that no new players may join
    lockRoom() {
        return this.send('room/lock');
    }

    // room/start-audience: signals that the room should accept audience
    // connections. Audience members never connect directly to the room, but
    // shards do. By default, rooms do not allow new clients to join with the
    // shard role. By sending room/start-audience, we signal to the room that
    // it should allow shard connections.
    startAudience() {
        return this.send('room/start-audience');
    }

    // room/get-audience: maybe misnamed, this gets the current audience data
    // for the room. I think at the moment it's just the audience count.
    getAudience() {
        return this.send('room/get-audience');
    }

    // client/send: this is definitely misnamed as "mail" and we should figure
    // out what to name it. This allows a client to send a message to another
    // client. Right now only the host role may send messages to clients, but
    // internally we could make it so that this allows players to send messages
    // to one another. Messages sent in this way are not persisted, they're
    // one-shot messages.
    mail(to, msg) {
        return this.send('client/send', {
            from: this.id,
            to,
            body: msg
        });
    }

    // client/kick: kicks a client from the server. The client receives a
    // client/kicked message informing them that they have been kicked. Clients
    // that are kicked should not automatically try to reconnect.
    kick(id, ban = false, reason) {
        return this.send('client/kick', { id, ban, reason });
    }

    // drop: deletes the entity at the specified key.
    // Hosts can drop anything. Other clients must have write permissions
    // in the entity's ACL.
    async drop(key) {
        const res = await this.send('drop', { key });
        delete this.entities[key];
        return res;
    }

    // echo: allows a client to send a string that will be echoed back by the
    // server. This can be used to test that a client connection is working.
    echo(s) {
        return this.send('echo', { message: s });
    }

    // lock: locks the entity from future updates
    // Hosts can lock anything. Other clients must have write permissions
    // in the entity's ACL.
    async lock(key) {
        const res = await this.send('lock', { key });
        this.entities[key].meta.locked = true;
        return res;
    }

    // number/create: create a new number entity with an initial value, along
    // with any restrictions on how that number can be updated
    async createNumber(key, options = {}) {
        let params = { key };

        const { val = 0, acl, min, max, increment, type } = options;

        params.val = val;

        if (acl) {
            params.acl = acl;
        }

        if (min != null) {
            params.min = min;
        }

        if (max != null) {
            params.max = max;
        }

        if (increment) {
            params.increment = increment;
        }

        if (type) {
            params.type = type;
        }

        const res = await this.send('number/create', params);
        this.entities[key] = new NumberEntity({
            key,
            val,
            restrictions: {
                min,
                max,
                increment,
                type
            },
            meta: { locked: false }
        });
        return res;
    }

    // number/decrement: decreases a number entity's value by the amount of its
    // `increment` restriction
    async decrementNumber(key) {
        const res = await this.send("number/decrement", { key });
        this.entities[key].val = res.val;
        return res;
    }

    // number/get: get the value of the number entity,
    // as well as the restrictions (min, max, increment, type)
    async getNumber(key) {
        const res = await this.send("number/get", { key });
        this.entities[key].val = res.val;
        this.entities[key].restrictions = res.restrictions;
        return res;
    }

    // number/increment: increases a number entity's value by the amount of its
    // `increment` restriction
    async incrementNumber(key) {
        const res = await this.send("number/increment", { key });
        this.entities[key].val = res.val;
        return res;
    }

    // number/update: update the value of the number entity, provided the new
    // value meets the entity's restrictions
    async updateNumber(key, val) {
        const res = await this.send('number/update', { key, val });
        this.entities[key].val = val;
        return res;
    }

    // object/create: creates an object entity
    async createObject(key, val, acl) {
        const params = { key, val };
        if (acl) {
            params.acl = acl;
        }

        const res = await this.send('object/create', params);
        this.entities[key] = new ObjectEntity({ key, val, meta: { locked: false } });
        return res;
    }

    // object/echo: echoes the value of an object entity
    echoObject(value) {
        return this.send('object/echo', { message: value });
    }

    // object/get: gets the value of an object entity
    async getObject(key) {
        const res = await this.send('object/get', { key });
        this.entities[key].val = res.val;
        this.entities[key].version = res.version;
        this.entities[key].from = res.from;
        return res;
    }

    // object/set: sets an object entity
    // If the entity already exists, the ACL cannot be changed
    // object/set will fail if an ACL is provided for an existing entity
    async setObject(key, val, acl) {
        const params = { key, val };
        if (acl) {
            params.acl = acl;
        }

        const res = await this.send('object/set', params);
        this.entities[key] = new ObjectEntity({ key, val, meta: { locked: false } });
        return res;
    }

    // object/update: updates the value of an existing entity
    // fails if the entity does not yet exist
    async updateObject(key, val) {
        const res = await this.send('object/update', { key, val });
        this.entities[key] = new ObjectEntity({ key, val, meta: { locked: false } });
        return res;
    }

    // text/echo: echoes the value of a text entity
    // This is just like `echo`, but is here for symmetry with object/echo
    echoText(text) {
        return this.send('text/echo', { message: text });
    }

    // text/get: this allows the client to query the server for a text entity.
    // I'm not sure that we actually need this since clients are sent
    // values as they are written.
    getText(key) {
        return this.send('text/get', { key });
    }

    // text/create: creates a text entity. Using createText rather than setText
    // allows for setting of filters
    async createText(key, val, options) {
        const params = { key, val };

        const { acl, accept, reject } = options;

        if (acl) {
            params.acl = acl;
        }
        if (accept) {
            params.accept = accept;
        }
        if (reject) {
            params.reject = reject;
        }

        const res = await this.send('text/create', params);
        this.entities[key] = new TextEntity({ key, text: val, meta: { locked: false } });
        return res;
    }

    // text/set: sets a text entity value. A text entity can have a value that
    // is any string; the value does not need to be valid json.
    // If the entity already exists, the ACL cannot be changed
    // text/set will fail if an ACL is provided for an existing entity
    async setText(key, val, acl) {
        const params = { key, val };
        if (acl) {
            params.acl = acl;
        }

        const res = await this.send('text/set', params);
        this.entities[key] = new TextEntity({ key, text: val, meta: { locked: false } });
        return res;
    }

    // text/update: updates the value of an existing text entity
    // Fails if the entity doesn't exist or the value doesn't
    // validate against the entity's constraints.
    async updateText(key, val) {
        const res = await this.send('text/update', { key, val });
        this.entities[key] = new TextEntity({ key, text: val, meta: { locked: false } });
        return res;
    }

    // text-map/create: create a new text map entity
    // Fails if you aren't the host. Accepts text filters
    async createTextMap(key, options = {}) {
        const { val, notifyHost, acl, accept, reject } = options;

        let params = { key };
        if (val) {
            params.val = options.val;
        }
        if (notifyHost) {
            params.notifyHost = options.notifyHost;
        }
        if (acl) {
            params.acl = acl;
        }
        if (accept) {
            params.accept = accept;
        }
        if (reject) {
            params.reject = reject;
        }

        const res = await this.send('text-map/create', params);
        this.entities[key] = new TextMapEntity({ key, acl, meta: { locked: false } });
        return res;
    }

    // text-map/sync: syncs the provided state (msg) to an existing
    // text map entity. Fails if the entity doesn't exist or the value
    // doesn't pass the text map's text filters.
    // We don't store the returned value in the entity map, since it would 
    // fall out of sync quickly anyways.
    async syncTextMap(key, msg) {
        const res = await this.send('text-map/sync', { key, msg });
        return res;
    }

    // text-map/get: requests the current state of the text map, which is returned
    // as plain text. Node attribution information can be included using
    // the includeNodes option
    async getTextMap(key, options) {
        const { includeNodes } = options;
        const res = await this.send('text-map/get', { key, includeNodes });
        return res;
    }

    // doodle/create: creates a new doodle entity
    // Fails if the session is not host or the provided height
    // or width are negative
    async createDoodle(key, options) {
        let params = { key };

        const { acl, colors, live, maxLayer, maxPoints, size, weights } = options;

        if (acl) {
            params.acl = acl;
        }

        if (colors) {
            params.colors = colors;
        }

        params.live = live;

        if (maxLayer != null) {
            params.maxLayer = maxLayer;
        }

        if (maxPoints != null) {
            params.maxPoints = maxPoints;
        }

        if (size) {
            params.size = size;
        }

        if (weights) {
            params.weights = weights;
        }

        const res = await this.send('doodle/create', params);
        this.entities[key] = new DoodleEntity({
            key,
            colors,
            lines: [],
            live,
            maxLayer: params.maxLayer || 0,
            maxPoints: params.maxPoints || 0,
            size,
            weights,
            meta: { locked: false }
        });
        return res;
    }

    // doodle/get: returns the current value of the doodle entity
    // Fails if the entity doesn't exist. Useful if the doodle entity opted-out
    // of sending notifications per update at the time it was created.
    async getDoodle(key) {
        const res = await this.send('doodle/get', { key });
        this.entities[key].lines = res.lines;
        return res;
    }

    // doodle/stroke: adds a line to an existing doodle
    // Fails if the entity doesn't exist or color, weight, or
    // any point's x/y coordinates fall outside the doodle's parameters
    async strokeDoodle(key, options) {
        const { color, weight, layer, points, brush } = options;
        const line = { color, weight, layer, points };

        // Track only meaningful brush values to avoid bloated line data
        if (brush) {
            line.brush = brush;
        }

        const res = await this.send('doodle/stroke', { key, ...line });
        this.entities[key].lines.push(line);
        return res;
    }

    // doodle/undo: removes the most recently added line from a doodle
    // Fails if the entity doesn't exist or there are no lines in the array
    async undoDoodle(key) {
        const res = await this.send('doodle/undo', { key });
        this.entities[key].lines.pop();
        return res;
    }

    // stack/create: creates a new empty stack
    // fails if the session is not host
    async createStack(key, acl) {
        const params = { key };

        if (acl) {
            params.acl = acl;
        }

        const res = await this.send('stack/create', params);
        this.entities[key] = new StackEntity({
            key,
            size: 0,
            meta: { locked: false }
        });

        return res;
    }

    // stack/push: takes a JSON object to be pushed onto the stack and returns OK
    // fails if the entity doesn't exist, or if the session doesn't have write permissions
    pushStack(key, val) {
        return this.send('stack/push', { key, val });
    }

    // stack/bulkpush: takes an array of JSON objects to be pushed onto the stack, in the
    // order in which they will be pushed, and returns OK
    // fails if the entity doesn't exist, or any one of the array members is not a valid JSON object, or if session doesn't have write permissions
    bulkPushStack(key, vals) {
        return this.send('stack/bulkpush', { key, vals });
    }


    // stack/peek: takes a size and returns that many items off the top of the stack, in their pop order
    // fails if entity doesn't exist, if size is larger than the size of the stack, or if session doesn't have read permissions
    peekStack(key, size) {
        return this.send('stack/peek', { key, size });
    }

    // stack/pop: removes the top item from the stack and returns it, or null if the stack is empty
    // fails if the entity doesn't exist or if session doesn't have write permissions
    popStack(key) {
        return this.send('stack/pop', { key });
    }

    // audience/count-group/create: creates a countgroup. A countgroup is a
    // group of counters. We use this to power things like audience voting. Any
    // audience member may increment the values in a countgroup.
    async createCountGroup(name, choices) {
        const res = await this.send('audience/count-group/create', {
            name,
            options: choices
        });
        this.entities[name] = new CountGroup({ key: name, choices, meta: { locked: false } });
        return res;
    }

    // audience/count-group/increment: increments an individual counter in an
    // countgroup.
    incrementCountGroupCounter(name, vote, times = 1) {
        return this.send('audience/count-group/increment', { name, vote, times });
    }

    // audience/count-group/get: queries the server for the current state of a
    // count-group.
    getCountGroup(name) {
        return this.send('audience/count-group/get', { name });
    }

    // audience/g-counter/create: creates a gcounter. A gcounter is a
    // grow-only counter that, as you may suspect, can only increase.
    async createGCounter(key, count) {
        const res = await this.send('audience/g-counter/create', { key, count });
        this.entities[key] = new GCounter({ key, count, meta: { locked: false } });
        return res;
    }

    // audience/g-counter/increment: adds at least 1 to the gcounter.
    // `times` can be used to increase the counter by more than one,
    // but negative increases (ugh) aren't allowed.
    incrementGCounter(key, times) {
        return this.send('audience/g-counter/increment', { key, times });
    }

    // audience/g-counter/get: queries the server for the current state of a
    // gcounter.
    getGCounter(key) {
        return this.send('audience/g-counter/get', { key });
    }

    // audience/pn-counter/create: creates a pncounter. A pncounter is a
    // positive-negative counter that can have values added or subtracted.
    async createPNCounter(key, count) {
        const res = await this.send('audience/pn-counter/create', { key, count });
        this.entities[key] = new PNCounter({ key, count, meta: { locked: false } });
        return res;
    }

    // audience/pn-counter/increment: adds at least 1 to the pncounter.
    // `times`(as a positive integer) can increase the counter by more than one.
    incrementPNCounter(key, times) {
        return this.send('audience/pn-counter/increment', { key, times });
    }

    // audience/pn-counter/decrement: subtracts at least 1 from the pncounter.
    // `times`(as a positive integer) can decrease the counter by more than one.
    decrementPNCounter(key, times) {
        return this.send('audience/pn-counter/decrement', { key, times });
    }

    // audience/pn-counter/get: queries the server for the current state of a
    // pncounter.
    getPNCounter(key) {
        return this.send('audience/pn-counter/get', { key });
    }

    // audience/text-ring/create: creates a text-ring. A text-ring is a
    // last-write-wins ring buffer of strings, limited to the provided capacity.
    // Elements are sorted by timestamp.
    async createTextRing(key, options) {
        const params = { key };

        const { limit, accept, reject } = options;

        if (limit) {
            params.limit = limit;
        }
        if (accept) {
            params.accept = accept;
        }
        if (reject) {
            params.reject = reject;
        }

        const res = await this.send('audience/text-ring/create', params);
        this.entities[key] = new TextRing({ key, elements: [], limit, meta: { locked: false } });
        return res;
    }

    // audience/text-ring/get: queries the server for the current state of a text-ring
    getTextRing(name) {
        return this.send('audience/text-ring/get', { name });
    }

    // audience/text-ring/push: appends the provided string to the text-ring
    pushTextRing(name, text) {
        return this.send('audience/text-ring/push', { name, text });
    }
}

module.exports = { WSClient };
