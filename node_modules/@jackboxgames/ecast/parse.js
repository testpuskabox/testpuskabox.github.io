const { ArtifactEntity } = require('./artifact');
const {
    ClientWelcome,
    ClientConnected,
    ClientDisconnected,
    ClientKicked,
    ClientSend,
} = require('./client');
const { CountGroup } = require('./count_group');
const { DoodleEntity, DoodleLine, DoodleLineRemoved } = require('./doodle');
const { StackEntity, StackElement, StackElements } = require('./stack');
const { DropEntity } = require('./drop');
const { Echo } = require('./echo');
const { LockEntity } = require('./lock');
const { GCounter } = require('./g_counter');
const { GetAudienceReply, RoomExit, RoomLock } = require('./room');
const { Notification } = require('./notification');
const { OK } = require('./ok');
const { NumberEntity } = require('./number');
const { ObjectEcho, ObjectEntity } = require('./object');
const { PNCounter } = require('./pn_counter');
const { Reply } = require('./reply');
const { TextEcho, TextEntity } = require('./text');
const { TextRing } = require('./text_ring');
const { createError, ObservedError } = require('./errors');
const { TextMapEntity, TextMapSynced, TextMapState } = require('./text_map');

// parseResult parses the result of a Reply or Notification message. This is
// overly ceremonial for JavaScript but serves as living documentation of the
// available fields in our messages.
function parseResult(typeName, result, meta) {
    switch (typeName) {
        case 'ok':
            // ok messages are sent as replies to indicate that a client's request
            // has been fulfilled, but that the server doesn't have anything else
            // to say about this. Clients can use ok messages to take action when
            // their requests have been completed by the server.
            return new OK();

        case 'echo':
            return new Echo({ message: result.message });

        case 'lock':
            return new LockEntity({
                key: result.key,
                from: result.from,
            });

        case 'error':
            // the error type represents an error. The types are name 
            // EcastClientError, EcastServerError, and CallError.
            // All three extend the base Error class. CallError is the
            // default if result.code is not a recognized error code.

            return createError({ code: result.code, message: result.msg });
        
        case 'error/observed':
            // only received by observer sessions, this is an indication that
            // another client has received an error as a reply. 
            return new ObservedError({
                to: result.to,
                opcode: result.opcode,
                error: createError({code: result.error.code, message: result.error.msg})
            });

        case 'string':
            // the string type means the result value is just a literal string,
            // not an object of any type whatsoever.
            return result;

        case 'text':
            // text messages indicate that the body of the reply or notification is
            // a text entity.
            return new TextEntity({
                from: result.from,
                key: result.key,
                text: result.val,
                version: result.version,
                meta: meta,
                acl: result.acl,
            });

        case 'text/echo':
            return new TextEcho({
                message: result.message,
            });

        case 'object':
            return new ObjectEntity({
                from: result.from,
                key: result.key,
                val: result.val,
                meta: meta,
                acl: result.acl,
            });

        case 'object/echo':
            return new ObjectEcho({
                message: result.message,
            });

        case 'drop':
            return new DropEntity({
                key: result.key
            });

        case 'artifact':
            return new ArtifactEntity({
                key: result.key,
                artifactId: result.artifactId,
                categoryId: result.categoryId,
                rootId: result.rootId,
                meta: meta
            });

        case 'client/connected':
            // client/connected is a notification that is sent to inform a client
            // that another client has connected.
            return new ClientConnected({
                id: result.id,
                userId: result.userId,
                name: result.name,
                role: result.role,
                reconnect: result.reconnect,
            });

        case 'client/disconnected':
            // client/disconnected is a notification that is sent to inform a
            // client that another client has disconnected.
            return new ClientDisconnected({
                id: result.id,
                role: result.role,
            });

        case 'client/kicked':
            // client/kicked is a notification that a client has been kicked from
            // the game.
            return new ClientKicked({
                id: result.id,
                banned: result.banned,
                reason: result.reason,
            });

        case 'client/send':
            // client/send is a notification that is sent to inform a client that
            // another client has sent them a message.
            return new ClientSend({
                to: result.to,
                from: result.from,
                body: result.body,
                userId: result.userID,
            });

        case 'client/welcome': {
            // client/welcome is a special case: it is sent by the server to a
            // client upon connection, as a result of that client having connected,
            // but is -not- a reply because clients do not have a sequence number
            // before connecting. It's technically a notification but clients don't
            // handle it as a notification, they handle it as part of the process
            // of establishing the initial connection to the room.
            let welcome = new ClientWelcome({
                id: result.id,
                name: result.name,
                secret: result.secret,
                reconnect: result.reconnect,
                here: result.here,
                profile: result.profile,
                // only present for host reconnects with replay
                replayEnd: result.replayEnd,
            });

            // there's a chance that entities will be undefined for host
            // reconnects with syncEntities set to false
            if (result.entities) {
                let entities = {};
                Object.entries(result.entities).forEach(([key, value]) => {
                    entities[key] = parseResult(value[0], value[1], value[2]);
                });
                welcome.entities = entities;
            }

            return welcome;
        }
        case 'doodle':
            return new DoodleEntity({
                key: result.key,
                colors: result.val.colors,
                lines: result.val.lines,
                live: result.val.live,
                maxLayer: result.val.maxLayer,
                maxPoints: result.val.maxPoints,
                size: result.val.size,
                weights: result.val.weights,
                meta: meta,
                acl: result.acl,
            });
        case 'doodle/line':
            return new DoodleLine({
                key: result.key,
                line: result.val
            });
        case 'doodle/line/removed':
            return new DoodleLineRemoved({
                key: result.key,
                index: result.index,
            });
        
        case 'stack': 
            return new StackEntity({
                key: result.key,
                size: result.size,
                from: result.from,
                version: result.version,
                meta: result.meta,
                acl: result.acl
            });
        case 'stack/element':
            return new StackElement({
                key: result.key,
                val: result.val
            });
        case 'stack/elements':
            return new StackElements({
                key: result.key,
                vals: result.vals
            });
        case 'number':
            return new NumberEntity({
                key: result.key,
                val: result.val,
                restrictions: result.restrictions,
                from: result.from,
                version: result.version,
                meta: meta,
                acl: result.acl,
            });
        case 'text-map':
            return new TextMapEntity({
                key: result.key,
                from: result.from,
                root: result.root,
                meta: meta,
                acl: result.acl,
            });
        case 'text-map/state':
            return new TextMapState({
                key: result.key,
                from: result.from,
                attributions: result.attributions,
                text: result.text
            });
        case 'text-map/synced': 
            return new TextMapSynced({
                key: result.key,
                from: result.from,
                msg: result.msg
            });
        case 'room/exit':
            // room/exit is sent to all clients to inform them that the room is
            // shutting down.
            //
            // TODO: determine whether the server should inform clients that any
            // pending requests are being canceled by sending a reply to each one.
            return new RoomExit({cause: result.cause});

        case 'room/lock':
            // room/lock is sent to clients to inform them that the room has been
            // locked, and that new players may not join.
            return new RoomLock();

        case 'room/get-audience':
            return new GetAudienceReply({
                connections: result.connections,
            });

        case 'audience':
            return new PNCounter({
                key: typeName,
                count: result[1],
            });

        case 'audience/count-group':
            return new CountGroup({
                key: result.key,
                choices: result.choices,
                meta: meta
            });

        case 'audience/text-ring':
            return new TextRing({
                key: result.key,
                elements: result.elements,
                meta: meta
            });

        case 'audience/g-counter': {
            return new GCounter({
                key: result.key,
                count: result.count,
                meta: meta
            });
        }

        case 'audience/pn-counter':
            return new PNCounter({
                key: result.key,
                count: result.count,
                meta: meta
            });

        default:
            console.error(`failed to parse result of type ${typeName}: ${JSON.stringify(result, null, 2)}`);
            return result;
    }
}

// parseResponseMessage parses a response message. It's important to keep our
// terminology straight here: a "response" as ecast defines it is any message
// that is sent to clients as a result of an event that has occured on the
// server. If the client caused that event to occur, from that client's
// perspective, the message is a "reply", since we're replying to their action.
// For all other clients, if they receive a response for the thing the first
// client did, it is a "notification", since they are being notified of a
// change that they may not have known was coming in advance. All response
// messages are either a Reply or a Notification.
function parseResponseMessage(e) {
    let data = JSON.parse(e.data);
    let typeName = data.opcode || data.type;

    // any response with an "re" field present is a reply. The "re" field is
    // like the "re: " subject line when you reply to an email. When a client
    // sends a request, that request is tagged with a sequence number ("seq").
    // The "re" field here will be equal to the "seq" field of the request to
    // which this message is a reply.
    if (data.re) {
        return new Reply({
            pc: data.pc,
            re: data.re,
            opcode: typeName,
            result: parseResult(typeName, data.result),
        });
    }

    // notifications occur when one client performs an action that other
    // clients should be informed of. When the game sets some data, the players
    // receive a notification of that data's change.
    return new Notification({
        pc: data.pc,
        opcode: typeName,
        result: parseResult(typeName, data.result),
    });
}

module.exports = { parseResponseMessage };
